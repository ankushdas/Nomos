proc asset p : (x : bool), (y : int) |- ($c : 1) = true

proc asset q : . |- (#c : 1) = false

type x = 1 -o 1

type bits = +{b0 : bits, b1 : bits, e : 1}
type ctr = &{inc : ctr, val : bits}
type listA = +{cons : A * listA, nil : 1}
type queue = &{ins : A -o queue,
               del : +{none : 1,
                       some : A * queue}}

type coin = 1
type lcoin = +{cons : coin * lcoin, nil : 1}

type money = &{value : int ^ money,
               add : money -o money,
               subtract : int -> +{sufficient : money * money,
                                   insufficient : money},
               coins : lcoin}

proc asset wallet : (n : int), ($l : lcoin) |- ($m : money) =
  {
    case $m (
      value => send $m (n);
               $m <- wallet <- n $l
    | add => $m1 <- recv $m ;
             $m1.value ;
             v = recv $m1 ;
             $m1.coins ;
             $k <- append <- $l $m1 ;
             let n1 = n+v ;
             $m <- wallet <- n1 $k
    | subtract => n1 = recv $m ;
                  if (n1 > n)
                  then
                    $m.insufficient ;
                    $m <- wallet <- n $l
                  else
                    $m.sufficient ;
                    $l1 <- remove <- n1 $l ;
                    $k <- recv $l1 ;
                    $m1 <- wallet <- n1 $k ;
                    send $m $m1 ;
                    let n2 = n - n1 ;
                    $m <- wallet <- n2 $l1
    | coins => $m <- $l
    )
  }

type auction = /\ <{11}| +{running : &{bid : int -> money -o |{1}> \/ auction,
                                       cancel : |{8}> \/ auction},
                           ended : &{collect : int -> +{won : lot * |{3}> \/ auction,
                                                       lost : money * \/ auction},
                                     cancel : |{8}> \/ auction}}

type bid = &{addr : int ^ bid, val : money}
type bids = +{cons : bid * bids, nil : 1}

proc contract run : ($b : bids), ($l : lot) |- (#sa : auction) =
{
  $la <- accept #sa ;
  $la.running ;
  case $la (
    bid => r = recv $la ;
           $m <- recv $la ;
           #sa <- detach $la ;
           $newb <- addbid <- r $b $m ;
           $sa <- run <- $newb $l
  | cancel => #sa <- detach $la ;
              #sa <- run <- $b $l
  )
}

proc contract end_lot : (w : int), ($b : bids), ($l : lot) |- (#sa : auction) =
{
  $la <- accept #sa ;
  $la.ended ;
  case $la (
    collect => r = recv $la ;
               if w = r
               then
                  $la.won ;
                  send $la $l ;
                  #sa <- detach $la ;
                  #sa <- end_nolot <- w $b
               else
                  $la.lost ;
                  $newb <- remove <- r $b ;
                  $m <- recv $newb ;
                  #sa <- detach $la ;
                  #sa <- end_lot <- w $b $l
  | cancel => #sa <- detach $la ;
              #sa <- end_lot <- w $b $l
  )
}
type val = 1

type dictionary = &{add : <{*}| int -> val -o dictionary,
                    delete : <{*}| int -> val * dictionary,
                    check : <{*}| int -> bool ^ dictionary}

proc asset newval : . |{*}- ($v : val) =
  {
    close $v
  }

proc asset dummy : . |{*}- ($d : dictionary) =
  {
    case $d (
      add => get $d {*} ;
             key = recv $d ;
             $v <- recv $d ;
             wait $v ;
             $d <- dummy <- 
    | delete => get $d {*} ;
                key = recv $d ;
                $v <- newval <- ;
                send $d $v ;
                $d <- dummy <- 
    | check => get $d {*} ;
               key = recv $d ;
               if key > 0
               then
                  send $d true ;
                  $d <- dummy <-
               else
                  send $d false ;
                  $d <- dummy <-
    )
  }

type money = 1
type lot = 1

proc asset addbid : (r : int), ($m : money), ($bs : dictionary) |{*}- ($newbs : dictionary) =
  {
    $bs.add ;
    pay $bs {*} ;
    send $bs r ;
    send $bs $m ;
    $newbs <- $bs
  }

type auction = /\ <{*}| +{running : &{bid : int -> money -o |{*}> \/ auction,
                                      cancel : |{*}> \/ auction},
                          ended : &{collect : int -> +{won : lot * |{*}> \/ auction,
                                                 lost : money * |{*}> \/ auction},
                                    cancel : |{*}> \/ auction}}

proc contract run : ($b : dictionary), ($l : lot) |{*}- (#sa : auction) =
{
  $la <- accept #sa ;
  get $la {*} ;
  $la.running ;
  case $la (
    bid => r = recv $la ;
           $m <- recv $la ;
           pay $la {*} ;
           #sa <- detach $la ;
           $newb <- addbid <- r $m $b ;
           $sa <- run <- $newb $l
  | cancel => pay $la {*} ;
              #sa <- detach $la ;
              #sa <- run <- $b $l
  )
}

proc asset removebid : (r : int), ($bs : dictionary) |{*}- ($newbs : money * dictionary) =
  {
    $bs.delete ;
    pay $bs {*} ;
    send $bs r ;
    $m <- recv $bs ;
    send $newbs $m ;
    $newbs <- $bs
  }

proc contract end_lot : (w : int), ($b : dictionary), ($l : lot) |{*}- (#sa : auction) =
{
  $la <- accept #sa ;
  get $la {*} ;
  $la.ended ;
  case $la (
    collect => r = recv $la ;
               if w = r
               then
                  $la.won ;
                  send $la $l ;
                  pay $la {*} ;
                  #sa <- detach $la ;
                  #sa <- end_nolot <- w $b
               else
                  $la.lost ;
                  $newb <- removebid <- r $b ;
                  $m <- recv $newb ;
                  send $la $m ;
                  pay $la {*} ;
                  #sa <- detach $la ;
                  #sa <- end_lot <- w $newb $l
  | cancel => pay $la {*} ;
              #sa <- detach $la ;
              #sa <- end_lot <- w $b $l
  )
}

proc contract end_nolot : (w : int), ($b : dictionary) |{*}- (#sa : auction) =
{
  $la <- accept #sa ;
  get $la {*} ;
  $la.ended ;
  case $la (
    collect => r = recv $la ;
               $la.lost ;
               $newb <- removebid <- r $b ;
               $m <- recv $newb ;
               send $la $m ;
               pay $la {*} ;
               #sa <- detach $la ;
               work {*} ;
               #sa <- end_nolot <- w $newb
  | cancel => pay $la {*} ;
              #sa <- detach $la ;
              work {*} ;
              #sa <- end_nolot <- w $b
  )
}
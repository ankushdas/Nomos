type sfork = /\ <{*}| p+{ acquired{0.6} : \/ sfork,
                          available{0.4} : \/ sfork}

proc transaction thinking : (#l : sfork), (#r : sfork) |{*}- ($p : 1) =
{
  work {1.} ;
  flip {0.5} (
    HH => $ll <- acquire #l ;
          pay $ll {*} ;
          pcase $ll (
            acquired =>
              #l <- release $ll ;
              $p <- thinking <- #l #r
          | available =>
              $rr <- acquire #r ;
              pay $rr {*} ;
              pcase $rr (
                acquired =>
                  #r <- release $rr ;
                  #l <- release $ll ;
                  $p <- thinking <- #l #r
              | available =>
                  $p <- eatingRL <- $ll $rr
              )
          )
  | TT => $rr <- acquire #r ;
          pay $rr {*} ;
          pcase $rr (
            acquired =>
              #r <- release $rr ;
              $p <- thinking <- #l #r
          | available =>
              $ll <- acquire #l ;
              pay $ll {*} ;
              pcase $ll (
                acquired =>
                  #l <- release $ll ;
                  #r <- release $rr ;
                  $p <- thinking <- #l #r
              | available =>
                  $p <- eatingLR <- $ll $rr
              )
          )
  )
}

proc transaction eatingRL : ($ll : \/ sfork), ($rr : \/ sfork) |{*}- ($p : 1) =
{
  #r <- release $rr ;
  #l <- release $ll ;
  close $p
}

proc transaction eatingLR : ($ll : \/ sfork), ($rr : \/ sfork) |{*}- ($p : 1) =
{
  #l <- release $ll ;
  #r <- release $rr ;
  close $p
}


proc contract fork_proc : . |{*}- (#f : sfork) =
{
  $lf <- accept #f ;
  get $lf {*} ;
  flip {0.6} (
    HH => $lf..acquired ;
          #f <- detach $lf ;
          #f <- fork_proc <-
  | TT => $lf..available ;
          #f <- detach $lf ;
          #f <- fork_proc <-
  )
}

type forklist = +{cons : |{*}> sfork * sfork * forklist, nil : 1}

type phillist = +{cons : 1 * phillist, nil : 1}

type potlist = +{cons : |{*}> potlist, nil : 1}

proc transaction fnil : . |{*}- ($fl : forklist) =
{
  $fl.nil ;
  close $fl
}

proc transaction create_forks_helper : ($l : potlist), (#prev : sfork) |{*}- ($fl : forklist) =
{
  case $l (
    cons => get $l {*} ;
            #f <- fork_proc <- ;
            $fl.cons ;
            pay $fl {*} ;
            send $fl #f ;
            send $fl #prev ;
            $fl <- create_forks_helper <- $l #f
  | nil => $fl.nil ;
           wait $l ;
           close $fl
  )
}

proc transaction create_forks : ($l : potlist) |{*}- ($fl : forklist) =
{
  #f <- fork_proc <- ;
  $fl <- create_forks_helper <- $l #f
}

proc transaction create_phils : ($fl : forklist) |{*}- ($pl : phillist) =
{
  case $fl (
    cons => get $fl {*} ;
            #f1 <- recv $fl ;
            #f2 <- recv $fl ;
            $pl.cons ;
            $p <- thinking <- #f1 #f2 ;
            send $pl $p ;
            $pl <- create_phils <- $fl
  | nil => $pl.nil ;
           wait $fl ;
           close $pl
  )
}
